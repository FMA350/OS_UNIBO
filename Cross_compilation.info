First of all you need to get the test program and compile it
into an object file with your cross-compiler:

$> cp /usr/share/doc/uarm/examples/helloworld.c .
	$> cd /usr/share/doc/uarm/examples/
$> arm-none-eabi-gcc -mcpu=arm7tdmi -c -o helloworld.o \
   helloworld.c
	$> arm-none-eabi-gcc -mcpu=arm7tdmi -c -o helloworld.o helloworld.c

This command builds an object file "helloworld.o" compiled
for ARM7TDMI processor.

Now you need to link the file against the system libraries:

$> arm-none-eabi-ld \
   -T /usr/include/uarm/ldscripts/elf32ltsarm.h.uarmcore.x \
   -o helloworld.elf /usr/include/uarm/crtso.o \
   /usr/include/uarm/libuarm.o helloworld.o

The "elf32ltsarm.h.uarmcore.x" file is a specific linker script
for linking uARM executables.

The last step remaining is to convert "helloworld.elf" into
a uARM core.uarm executable file:

$> elf2uarm -k helloworld.elf

The last command with -k flag created a core file inside the
same directory as the original elf file wich can be executed
from uARM virtual machine

----------------------------------------------------------------------------------------------------------------------------------------------------

Il percorso dove si trovano le librerie Ã¨:
/usr/include/uarm/
Per permetterle al compilatore di includerle dobbiamo compilare con
 -I /usr/include/uarm/

Per compilare il file oggetto:
arm-none-eabi-gcc -mcpu=arm7tdmi -c mikabooq.c -o mikabooq.o -I /usr/include/uarm

------------------------------------IMPORTANTE----------------------------------------------------------------------------------------
NO ----> for(size_t i = 0; ---- ; ---- ){ ...

SI -----> size_t i;
		for(i = 0; ---- ; ---- ){ ...

Per fare accettare la prima opzione al compilatore bisogna compilare
usando l'opzione -std=c99.
Questa opzione tuttavia fa comparire molti errori sulle macro
offset_of e container_of














